@top Flowchart { statement* }

statement {
  GRAPH |
  SUBGRAPH |
  END |
  DIR |
  STYLE |
  CLICK |
  LINKSTYLE |
  CLASSDEF |
  CLASS |
  DEFAULT |
  INTERPOLATE |
  HREF |
  LINK_TARGET |
  STR |
  LINK |
  PIPE |
  SEMI |
  Hyphen |
  At |
  SquareStart | SquareEnd |
  ParenStart | ParenEnd |
  DiamondStart | DiamondEnd |
  DoubleCircleStart | DoubleCircleEnd |
  TagEnd |
  SubroutineStart | SubroutineEnd |
  CylinderStart | CylinderEnd |
  StadiumStart | StadiumEnd |
  TrapStart | TrapEnd |
  InvTrapStart | InvTrapEnd |
  newline |
  // Vertex patterns - more specific to avoid conflicts
  NODE_STRING AMP NODE_STRING |
  NODE_STRING AMP NODE_STRING LINK NODE_STRING |
  NODE_STRING LINK NODE_STRING AMP NODE_STRING |
  NODE_STRING LINK NODE_STRING LINK NODE_STRING |
  NODE_STRING
}

GRAPH { graphKeyword }
SUBGRAPH { subgraph }
END { end }
DIR { direction }
STYLE { styleKeyword }
CLICK { clickKeyword }
LINKSTYLE { linkStyleKeyword }
CLASSDEF { classDefKeyword }
CLASS { classKeyword }
DEFAULT { defaultKeyword }
INTERPOLATE { interpolateKeyword }
HREF { hrefKeyword }

LINK_TARGET { linkTargetKeyword }
NODE_STRING { identifier }
STR { string }
LINK { arrow }
PIPE { pipe }
SEMI { semi }
AMP { amp }
Hyphen { hyphen }
At { at }
SquareStart { squareStart }
SquareEnd { squareEnd }
ParenStart { parenStart }
ParenEnd { parenEnd }
DiamondStart { diamondStart }
DiamondEnd { diamondEnd }
DoubleCircleStart { doubleCircleStart }
DoubleCircleEnd { doubleCircleEnd }
TagEnd { tagEnd }
SubroutineStart { subroutineStart }
SubroutineEnd { subroutineEnd }
CylinderStart { cylinderStart }
CylinderEnd { cylinderEnd }
StadiumStart { stadiumStart }
StadiumEnd { stadiumEnd }
TrapStart { trapStart }
TrapEnd { trapEnd }
InvTrapStart { invTrapStart }
InvTrapEnd { invTrapEnd }

@tokens {
  // Whitespace and control
  space { $[ \t]+ }
  newline { $[\n\r]+ }

  // Comments (skip these)
  Comment { "%%" ![\n]* }

  // Keywords (exact matches, highest precedence)
  @precedence { string, graphKeyword, subgraph, end, direction, styleKeyword, clickKeyword, linkStyleKeyword, classDefKeyword, classKeyword, defaultKeyword, interpolateKeyword, hrefKeyword, linkTargetKeyword, identifier }
  graphKeyword { "flowchart-elk" | "flowchart" | "graph" }
  subgraph { "subgraph" }
  end { "end" }

  // Direction keywords (include single character directions)
  direction { "LR" | "RL" | "TB" | "BT" | "TD" | "BR" | "v" | "^" }

  // Style and interaction keywords
  styleKeyword { "style" }
  clickKeyword { "click" }
  linkStyleKeyword { "linkStyle" }
  classDefKeyword { "classDef" }
  classKeyword { "class" }
  defaultKeyword { "default" }
  interpolateKeyword { "interpolate" }
  hrefKeyword { "href" }

  linkTargetKeyword { "_self" | "_blank" | "_parent" | "_top" }

  // Arrow patterns - exact match to JISON patterns for 100% compatibility
  @precedence { arrow, hyphen, identifier }
  arrow {
    // Normal arrows - JISON: [xo<]?\-\-+[-xo>]
    // Optional left head + 2+ dashes + right ending
    "x--" $[-]* $[-xo>] |     // x + 2+ dashes + ending
    "o--" $[-]* $[-xo>] |     // o + 2+ dashes + ending
    "<--" $[-]* $[-xo>] |     // < + 2+ dashes + ending
    "--" $[-]* $[-xo>] |      // 2+ dashes + ending (includes --> and ---)

    // Edge text start patterns - for patterns like A<-- text -->B and A x== text ==x B
    // These need to be separate from complete arrows to handle edge text properly
    "<--" |                   // Left-pointing edge text start (matches START_LINK)
    "<==" |                   // Left-pointing thick edge text start
    "<-." |                   // Left-pointing dotted edge text start (matches START_DOTTED_LINK)
    "x--" |                   // Cross head open normal start (A x-- text --x B)
    "o--" |                   // Circle head open normal start (A o-- text --o B)
    "x==" |                   // Cross head open thick start (A x== text ==x B)
    "o==" |                   // Circle head open thick start (A o== text ==o B)
    "x-." |                   // Cross head open dotted start (A x-. text .-x B)
    "o-." |                   // Circle head open dotted start (A o-. text .-o B)

    // Thick arrows - JISON: [xo<]?\=\=+[=xo>]
    // Optional left head + 2+ equals + right ending
    "x==" $[=]* $[=xo>] |     // x + 2+ equals + ending
    "o==" $[=]* $[=xo>] |     // o + 2+ equals + ending
    "<==" $[=]* $[=xo>] |     // < + 2+ equals + ending
    "==" $[=]* $[=xo>] |      // 2+ equals + ending (includes ==> and ===)

    // Dotted arrows - JISON: [xo<]?\-?\.+\-[xo>]?
    // Optional left head + optional dash + 1+ dots + dash + optional right head
    "x-" $[.]+ "-" $[xo>]? |  // x + dash + dots + dash + optional ending
    "o-" $[.]+ "-" $[xo>]? |  // o + dash + dots + dash + optional ending
    "<-" $[.]+ "-" $[xo>]? |  // < + dash + dots + dash + optional ending
    "-" $[.]+ "-" $[xo>]? |   // dash + dots + dash + optional ending
    $[.]+ "-" $[xo>]? |       // dots + dash + optional ending (for patterns like .-)

    // Invisible links - JISON: \~\~[\~]+
    "~~" $[~]* |              // 2+ tildes

    // Basic fallback patterns for edge cases
    "--" | "==" | "-."
  }

  // Punctuation tokens
  pipe { "|" }
  semi { ";" }
  amp { "&" }
  hyphen { "-" }
  at { "@" }

  // Shape delimiters - Basic
  squareStart { "[" }
  squareEnd { "]" }
  parenStart { "(" }
  parenEnd { ")" }
  diamondStart { "{" }
  diamondEnd { "}" }

  // Shape delimiters - Complex (higher precedence to match longer patterns first)
  @precedence { doubleCircleStart, doubleCircleEnd, subroutineStart, subroutineEnd, cylinderStart, cylinderEnd, stadiumStart, stadiumEnd, trapStart, trapEnd, invTrapStart, invTrapEnd, parenStart, squareStart }
  doubleCircleStart { "(((" }
  doubleCircleEnd { ")))" }
  subroutineStart { "[[" }
  subroutineEnd { "]]" }
  cylinderStart { "[(" }
  cylinderEnd { ")]" }
  stadiumStart { "([" }
  stadiumEnd { "])" }
  trapStart { "[/" }
  trapEnd { "/]" }
  invTrapStart { "[\\" }
  invTrapEnd { "\\]" }

  // Other shape tokens
  tagEnd { ">" }

  // Simple string literals
  string { '"' (!["\\] | "\\" _)* '"' | "'" (!['\\] | "\\" _)* "'" }

  // Node identifiers - more permissive pattern to match JISON NODE_STRING
  // Supports: letters, numbers, underscore, and safe special characters
  // Handles both pure numbers (like "1") and alphanumeric IDs (like "1id")
  identifier { $[a-zA-Z0-9_!\"#$'*+.`?=:-]+ }
}

@skip { space | Comment }


