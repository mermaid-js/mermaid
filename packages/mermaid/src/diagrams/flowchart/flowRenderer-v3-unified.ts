import { select, selectAll } from 'd3';
import { getConfig } from '../../diagram-api/diagramAPI.js';
import type { DiagramStyleClassDef } from '../../diagram-api/types.js';
import { log } from '../../logger.js';
import { getDiagramElement } from '../../rendering-util/insertElementsForSize.js';
import { getRegisteredLayoutAlgorithm, render } from '../../rendering-util/render.js';
import { setupViewPortForSVG } from '../../rendering-util/setupViewPortForSVG.js';
import type { LayoutData } from '../../rendering-util/types.js';
import utils from '../../utils.js';

export const getClasses = function (
  _text: string,
  diagramObj: { db: { getClasses: () => Map<string, DiagramStyleClassDef> } }
): Map<string, DiagramStyleClassDef> {
  return diagramObj.db.getClasses();
};

export const draw = async function (
  _text: string,
  id: string,
  _version: string,
  diag: {
    db: any;
    type: string;
  }
) {
  log.info('Drawing flowchart diagram (v3)', id);

  const { securityLevel, flowchart: conf, layout } = getConfig();

  /* =====================================================
     Sandbox document handling
     ===================================================== */
  let sandboxElement: ReturnType<typeof select> | undefined;

  if (securityLevel === 'sandbox') {
    sandboxElement = select(`#i${id}`);
  }

  // @ts-expect-error -- contentDocument exists on sandbox iframe at runtime
  const doc: Document =
    securityLevel === 'sandbox'
      ? (sandboxElement!.nodes()[0] as HTMLIFrameElement).contentDocument
      : document;

  const data4Layout = diag.db.getData() as LayoutData;

  /* =====================================================
     SVG ROOT â€” ACCESSIBILITY (Issue 2)
     ===================================================== */
  const svg = getDiagramElement(id, securityLevel);

  svg.attr('role', 'img').attr('aria-labelledby', `${id}-title ${id}-desc`);

  svg
    .append('title')
    .attr('id', `${id}-title`)
    .text(diag.db.getAccTitle() ?? diag.db.getDiagramTitle() ?? 'Mermaid flowchart diagram');

  svg
    .append('desc')
    .attr('id', `${id}-desc`)
    .text(diag.db.getAccDescription() ?? 'Flowchart diagram generated by Mermaid');

  /* ===================================================== */

  const direction = diag.db.getDirection();

  data4Layout.type = diag.type;
  data4Layout.layoutAlgorithm = getRegisteredLayoutAlgorithm(layout);

  if (data4Layout.layoutAlgorithm === 'dagre' && layout === 'elk') {
    log.warn(
      'flowchart-elk was moved to an external package in Mermaid v11. Falling back to dagre.'
    );
  }

  data4Layout.direction = direction;
  data4Layout.nodeSpacing = conf?.nodeSpacing ?? 50;
  data4Layout.rankSpacing = conf?.rankSpacing ?? 50;
  data4Layout.markers = ['point', 'circle', 'cross'];
  data4Layout.diagramId = id;

  await render(data4Layout, svg);

  const padding = data4Layout.config.flowchart?.diagramPadding ?? 8;

  utils.insertTitle(
    svg,
    'flowchartTitleText',
    conf?.titleTopMargin ?? 0,
    diag.db.getDiagramTitle()
  );

  setupViewPortForSVG(svg, padding, 'flowchart', conf?.useMaxWidth ?? false);

  /* =====================================================
     NODE ACCESSIBILITY (Issue 3)
     ===================================================== */
  for (const vertex of data4Layout.nodes) {
    const node = select(`#${id} [id="${vertex.id}"]`);

    if (!node.empty()) {
      const labelText = vertex.label ?? vertex.text ?? 'Unnamed node';

      node
        .attr('role', 'group')
        .attr('tabindex', '0')
        .attr('aria-label', `Flowchart node ${vertex.id}: ${labelText}`);
    }
  }

  /* =====================================================
     EDGE ACCESSIBILITY (Issue 3)
     ===================================================== */
  selectAll(`#${id} .edgePath path`)
    .attr('role', 'img')
    .attr('aria-label', function () {
      const edgeLabel = select(this.parentNode as SVGGElement)
        .select('.edgeLabel')
        .text();

      return edgeLabel ? `Flowchart connection: ${edgeLabel}` : 'Flowchart connection';
    });

  /* =====================================================
     LINK WRAPPING (unchanged behavior)
     ===================================================== */
  for (const vertex of data4Layout.nodes) {
    const node = select(`#${id} [id="${vertex.id}"]`);
    if (node.empty() || !vertex.link) {
      continue;
    }

    const link = doc.createElementNS('http://www.w3.org/2000/svg', 'a');

    link.setAttribute('class', vertex.cssClasses ?? '');
    link.setAttribute('rel', 'noopener');

    if (securityLevel === 'sandbox') {
      link.setAttribute('target', '_top');
    } else if (vertex.linkTarget) {
      link.setAttribute('target', vertex.linkTarget);
    }

    const linkNode = node.insert(() => link, ':first-child');

    const shape = node.select('.label-container');
    if (!shape.empty()) {
      linkNode.append(() => shape.node());
    }

    const label = node.select('.label');
    if (!label.empty()) {
      linkNode.append(() => label.node());
    }
  }
};

export default {
  getClasses,
  draw,
};
