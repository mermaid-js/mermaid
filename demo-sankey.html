<!DOCTYPE html>
<html>
<head>
    <title>Sankey Apple Style Demo V25 (Auto-Zoom + Animation)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; padding: 40px; background: #f5f5f7; user-select: none; }
        h2 { font-weight: 600; color: #1d1d1f; }
        svg { background: #fff; border-radius: 18px; box-shadow: 0 4px 20px rgba(0,0,0,0.05); overflow: visible; }

        .node rect { shape-rendering: crispEdges; cursor: pointer; transition: fill-opacity 0.2s; }
        .node rect:hover { fill-opacity: 0.8; }
        .label { font-size: 11px; font-weight: 600; fill: #1d1d1f; pointer-events: none; }
        .label-bg { stroke: rgba(255,255,255,0.8); stroke-width: 4px; stroke-linejoin: round; paint-order: stroke; }
        .indicator { pointer-events: none; fill: #fff; stroke: none; }
        .link { fill: none; stroke-opacity: 0.5; mix-blend-mode: multiply; }
        .link:hover { stroke-opacity: 0.8; }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
</head>
<body>
    <h2>Apple Style V25: Auto-Zoom + Collapse Animation</h2>
    <p style="color:#666; font-size: 13px;">
        Only Revenue (center) can collapse both sides. Other nodes collapse only their children.<br>
        Graph auto-zooms to fill canvas. Nodes animate towards/from anchor.
    </p>
    <div id="chart" style="margin-left: 100px; margin-right: 100px;"></div>

    <script>
        // RAW DATA
        const rawNodes = [
            { id: "iPhone", color: "#6e6e73" },
            { id: "Mac", color: "#6e6e73" },
            { id: "iPad", color: "#6e6e73" },
            { id: "Wearables", color: "#6e6e73" },
            { id: "Products", color: "#6e6e73" },
            { id: "Services", color: "#6e6e73" },
            { id: "Revenue", color: "#424245" },
            { id: "Cost of Revenue", color: "#ff3b30" },
            { id: "Gross Profit", color: "#34c759" },
            { id: "Op Expenses", color: "#ff3b30" },
            { id: "Op Profit", color: "#34c759" },
            { id: "Tax", color: "#ff3b30" },
            { id: "Net Profit", color: "#34c759" }
        ];

        const rawLinks = [
            { source: "iPhone", target: "Products", value: 205 },
            { source: "Mac", target: "Products", value: 40 },
            { source: "iPad", target: "Products", value: 29 },
            { source: "Wearables", target: "Products", value: 41 },
            { source: "Products", target: "Revenue", value: 315 },
            { source: "Services", target: "Revenue", value: 78 },
            { source: "Revenue", target: "Cost of Revenue", value: 223 },
            { source: "Revenue", target: "Gross Profit", value: 170 },
            { source: "Gross Profit", target: "Op Expenses", value: 51 },
            { source: "Gross Profit", target: "Op Profit", value: 119 },
            { source: "Op Profit", target: "Tax", value: 19 },
            { source: "Op Profit", target: "Net Profit", value: 100 }
        ];

        const width = 800;
        const height = 500;
        const baseNodeWidth = 20;
        const centralNodeWidth = 30;

        // --- PRECOMPUTE TOPOLOGY ---
        const nodeSortMap = new Map();
        rawNodes.forEach((n, i) => nodeSortMap.set(n.id, i));

        const nodeLayerMap = new Map();
        let centralNodeId = null;
        let centralNodeLayer = 0;

        function precomputeTopology() {
            // Run sankey on FULL data to get layers and identify central node
            const sankey = d3.sankey()
                .nodeId(d => d.id)
                .nodeWidth(baseNodeWidth)
                .nodePadding(40)
                .nodeAlign(d3.sankeyLeft)
                .extent([[1, 1], [width - 1, height - 20]])
                .nodeSort((a, b) => nodeSortMap.get(a.id) - nodeSortMap.get(b.id));

            const graph = sankey({
                nodes: rawNodes.map(d => ({...d})),
                links: rawLinks.map(d => ({...d}))
            });

            let maxVal = 0;
            graph.nodes.forEach(n => {
                nodeLayerMap.set(n.id, n.layer);
                if (n.value > maxVal) {
                    maxVal = n.value;
                    centralNodeId = n.id;
                    centralNodeLayer = n.layer;
                }
            });
        }
        precomputeTopology();

        let collapsedStates = new Set();
        let lastAnchorNode = null; // For animation

        const svg = d3.select("#chart").append("svg")
            .attr("width", width).attr("height", height).attr("viewBox", [0, 0, width, height]);

        // Node classification
        function isWideNode(id) {
            return id === centralNodeId;
        }

        function isBridgeNode(id) {
            const hasIn = rawLinks.some(l => l.target === id);
            const hasOut = rawLinks.some(l => l.source === id);
            return hasIn && hasOut;
        }

        // Determine which direction a node can collapse
        // - Central node: can collapse BOTH directions
        // - Left-of-center nodes: collapse their inputs (target direction) = hide upstream "children"
        // - Right-of-center nodes: collapse their outputs (source direction) = hide downstream "children"
        function getCollapseDirection(id) {
            if (id === centralNodeId) return 'both';
            const layer = nodeLayerMap.get(id);
            if (layer < centralNodeLayer) {
                // Left of center: "children" are upstream (inputs)
                return 'target';
            } else {
                // Right of center: "children" are downstream (outputs)
                return 'source';
            }
        }

        function getNodeMeta(id) {
            const incoming = rawLinks.filter(l => l.target === id);
            const outgoing = rawLinks.filter(l => l.source === id);
            const isWide = isWideNode(id);
            const isBridge = isBridgeNode(id);
            const hasLeftChildren = incoming.length > 0;
            const hasRightChildren = outgoing.length > 0;
            const collapseDir = getCollapseDirection(id);

            let primaryDir = 'source';
            if (incoming.length === 0 && outgoing.length > 0) primaryDir = 'source';
            else if (outgoing.length === 0 && incoming.length > 0) primaryDir = 'target';
            else primaryDir = collapseDir === 'both' ? 'target' : collapseDir;

            return { isWide, isBridge, hasLeftChildren, hasRightChildren, collapseDir, primaryDir };
        }

        function getPrunedGraph() {
            const isLinkBlocked = (l) =>
                collapsedStates.has(`source:${l.source}`) ||
                collapsedStates.has(`target:${l.target}`);

            let activeLinks = rawLinks.map(d => ({...d})).filter(l => !isLinkBlocked(l));
            let activeNodeIds = new Set(rawNodes.map(n => n.id));

            let changed = true;
            while (changed) {
                changed = false;
                const counts = new Map();
                activeNodeIds.forEach(id => counts.set(id, { in: 0, out: 0 }));
                const validLinks = activeLinks.filter(l => activeNodeIds.has(l.source) && activeNodeIds.has(l.target));
                validLinks.forEach(l => { counts.get(l.source).out++; counts.get(l.target).in++; });

                const nextActiveNodeIds = new Set();
                activeNodeIds.forEach(id => {
                    const rawHasIn = rawLinks.some(l => l.target === id);
                    const rawHasOut = rawLinks.some(l => l.source === id);
                    const currIn = counts.get(id).in;
                    const currOut = counts.get(id).out;
                    let keep = true;
                    if (rawHasIn && currIn === 0) keep = false;
                    if (rawHasOut && currOut === 0) keep = false;
                    const isAnchor = collapsedStates.has(`source:${id}`) || collapsedStates.has(`target:${id}`);
                    if (isAnchor && (currIn > 0 || currOut > 0)) keep = true;
                    if (keep) nextActiveNodeIds.add(id);
                });

                if (nextActiveNodeIds.size !== activeNodeIds.size) {
                    activeNodeIds = nextActiveNodeIds;
                    changed = true;
                    activeLinks = validLinks.filter(l => nextActiveNodeIds.has(l.source) && nextActiveNodeIds.has(l.target));
                }
            }

            return {
                nodes: rawNodes.filter(d => activeNodeIds.has(d.id)).map(d => ({...d})),
                links: activeLinks
            };
        }

        // Store previous positions for animation
        let prevPositions = new Map();

        function render() {
            const graphData = getPrunedGraph();

            // Re-run sankey layout on pruned data for AUTO-ZOOM
            const sankey = d3.sankey()
                .nodeId(d => d.id)
                .nodeWidth(baseNodeWidth)
                .nodePadding(40)
                .nodeAlign(d3.sankeyLeft)
                .extent([[1, 1], [width - 1, height - 20]])
                .nodeSort((a, b) => nodeSortMap.get(a.id) - nodeSortMap.get(b.id));

            const graph = sankey(graphData);
            const t = svg.transition().duration(600).ease(d3.easeCubicInOut);

            // Get anchor position for enter/exit animations
            const anchorPos = lastAnchorNode ? prevPositions.get(lastAnchorNode) : null;

            // LINKS
            const link = svg.selectAll(".link").data(graph.links, d => `${d.source.id}-${d.target.id}`);

            link.enter().append("path").attr("class", "link")
                .attr("d", d3.sankeyLinkHorizontal())
                .attr("stroke", d => d.target.color || "#e5e5ea")
                .attr("stroke-width", d => Math.max(1, d.width))
                .style("opacity", 0)
                .transition(t).style("opacity", 1);

            link.transition(t)
                .attr("d", d3.sankeyLinkHorizontal())
                .attr("stroke-width", d => Math.max(1, d.width));

            link.exit().transition(t).style("opacity", 0).remove();

            // NODES
            const node = svg.selectAll(".node-group").data(graph.nodes, d => d.id);

            const nodeEnter = node.enter().append("g").attr("class", "node-group");
            nodeEnter.append("rect").attr("class", "node");
            nodeEnter.append("text").attr("class", "label label-bg");
            nodeEnter.append("text").attr("class", "label label-fg");
            nodeEnter.append("path").attr("class", "indicator indicator-left");
            nodeEnter.append("path").attr("class", "indicator indicator-right");

            // ENTER: Animate from anchor or fade in
            nodeEnter.each(function(d) {
                const g = d3.select(this);
                const startPos = anchorPos || { x0: d.x0, y0: d.y0, y1: d.y1 };

                g.attr("transform", `translate(${startPos.x0}, ${startPos.y0})`)
                    .style("opacity", 0);

                g.select("rect")
                    .attr("height", anchorPos ? 1 : Math.max(1, d.y1 - d.y0))
                    .attr("width", baseNodeWidth)
                    .attr("fill", d.color || "#8e8e93");
            });

            nodeEnter.transition(t)
                .attr("transform", d => `translate(${d.x0}, ${d.y0})`)
                .style("opacity", 1);

            nodeEnter.select("rect").transition(t)
                .attr("height", d => Math.max(1, d.y1 - d.y0));

            // UPDATE: Smooth transition
            const nodeUpdate = node.merge(nodeEnter);

            nodeUpdate.transition(t)
                .attr("transform", d => `translate(${d.x0}, ${d.y0})`)
                .style("opacity", 1);

            nodeUpdate.select("rect").transition(t)
                .attr("height", d => Math.max(1, d.y1 - d.y0))
                .attr("width", d => {
                    const meta = getNodeMeta(d.id);
                    return meta.isWide ? centralNodeWidth : baseNodeWidth;
                })
                .attr("x", d => {
                    const meta = getNodeMeta(d.id);
                    if (meta.isWide) return -(centralNodeWidth - baseNodeWidth) / 2;
                    return 0;
                })
                .attr("fill", d => d.color || "#8e8e93");

            // Click handler
            nodeUpdate.select("rect").on("click", (e, d) => {
                const meta = getNodeMeta(d.id);
                lastAnchorNode = d.id;

                if (meta.collapseDir === 'both') {
                    // Central node: use click position
                    const rect = e.target.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    if (clickX < rect.width / 2) {
                        toggleCollapseDir(d, 'target');
                    } else {
                        toggleCollapseDir(d, 'source');
                    }
                } else if (meta.collapseDir === 'target' && meta.hasLeftChildren) {
                    toggleCollapseDir(d, 'target');
                } else if (meta.collapseDir === 'source' && meta.hasRightChildren) {
                    toggleCollapseDir(d, 'source');
                }
            });

            // Indicators
            nodeUpdate.select(".indicator-left")
                .attr("transform", d => {
                    const meta = getNodeMeta(d.id);
                    const nodeW = meta.isWide ? centralNodeWidth : baseNodeWidth;
                    const offsetX = meta.isWide ? -(centralNodeWidth - baseNodeWidth) / 2 : 0;
                    return `translate(${offsetX + nodeW / 6}, ${(d.y1 - d.y0) / 2})`;
                })
                .attr("d", d => {
                    const meta = getNodeMeta(d.id);
                    // Only show for central node OR left-of-center nodes
                    if (meta.collapseDir !== 'both' && meta.collapseDir !== 'target') return null;
                    if (!meta.hasLeftChildren) return null;
                    if (!collapsedStates.has(`target:${d.id}`)) return null;
                    return "M2,-3 L-2,0 L2,3";
                });

            nodeUpdate.select(".indicator-right")
                .attr("transform", d => {
                    const meta = getNodeMeta(d.id);
                    const nodeW = meta.isWide ? centralNodeWidth : baseNodeWidth;
                    const offsetX = meta.isWide ? -(centralNodeWidth - baseNodeWidth) / 2 : 0;
                    return `translate(${offsetX + nodeW * 5 / 6}, ${(d.y1 - d.y0) / 2})`;
                })
                .attr("d", d => {
                    const meta = getNodeMeta(d.id);
                    // Only show for central node OR right-of-center nodes
                    if (meta.collapseDir !== 'both' && meta.collapseDir !== 'source') return null;
                    if (!meta.hasRightChildren) return null;
                    if (!collapsedStates.has(`source:${d.id}`)) return null;
                    return "M-2,-3 L2,0 L-2,3";
                });

            // Labels
            const setLabel = (sel) => {
                sel.text(d => `${d.id} $${Math.round(d.value)}B`)
                    .attr("y", d => (d.y1 - d.y0) / 2).attr("dy", "0.35em")
                    .attr("x", d => {
                        const meta = getNodeMeta(d.id);
                        if (meta.isWide) {
                            return (centralNodeWidth - baseNodeWidth) / 2 + baseNodeWidth / 2;
                        }
                        const layer = nodeLayerMap.get(d.id);
                        if (layer < centralNodeLayer) return -10;
                        return baseNodeWidth + 10;
                    })
                    .attr("text-anchor", d => {
                        const meta = getNodeMeta(d.id);
                        if (meta.isWide) return "middle";
                        const layer = nodeLayerMap.get(d.id);
                        if (layer < centralNodeLayer) return "end";
                        return "start";
                    });
            };
            nodeUpdate.select(".label-bg").call(setLabel);
            nodeUpdate.select(".label-fg").call(setLabel);

            // EXIT: Animate towards anchor
            node.exit().each(function(d) {
                const g = d3.select(this);
                const targetPos = anchorPos || { x0: d.x0, y0: d.y0 + (d.y1 - d.y0) / 2 };

                g.transition(t)
                    .attr("transform", `translate(${targetPos.x0}, ${targetPos.y0})`)
                    .style("opacity", 0);

                g.select("rect").transition(t)
                    .attr("height", 1);
            }).transition(t).remove();

            // Store current positions for next render
            prevPositions.clear();
            graph.nodes.forEach(n => {
                prevPositions.set(n.id, { x0: n.x0, y0: n.y0, y1: n.y1 });
            });
        }

        function toggleCollapseDir(d, dir) {
            const key = `${dir}:${d.id}`;
            if (collapsedStates.has(key)) collapsedStates.delete(key);
            else collapsedStates.add(key);
            render();
        }

        render();
    </script>
</body>
</html>
